// Esperar a que el DOM esté completamente cargado
document.addEventListener('DOMContentLoaded', function() {
    setupStarsCanvas();
    setupSimpsonSilhouette();
    setupPlayer();
    startShootingStars();
});

// Detectar dispositivo móvil (basado en ancho de ventana)
function isMobileDevice() {
    return window.innerWidth <= 768;
}

let canvas, ctx, stars = [];
let animationFrameId;
let canvasWidth, canvasHeight;

function setupStarsCanvas() {
    // Crear elemento canvas
    canvas = document.createElement('canvas');
    canvas.id = 'stars-canvas';

    // Estilo del canvas
    canvas.style.position = 'fixed';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.zIndex = '-2';

    // Reemplazar el contenedor de estrellas con el canvas
    const starsContainer = document.getElementById('stars-container');
    if (starsContainer) {
        starsContainer.parentNode.replaceChild(canvas, starsContainer);
    } else {
        document.body.appendChild(canvas);
    }

    // Obtener contexto 2D para dibujar
    ctx = canvas.getContext('2d');

    // Configurar tamaño del canvas para que coincida con la ventana
    resizeCanvas();

    // Escuchar eventos de cambio de tamaño
    window.addEventListener('resize', function() {
        resizeCanvas();
        createStars(); // Recrear estrellas al cambiar el tamaño
    });

    // Crear estrellas y empezar la animación
    createStars();
    animate();

    // Crear nebulosas (efectos de fondo)
    createNebulas();
}

function resizeCanvas() {
    const smallScreen = isMobileDevice();
    canvasWidth = window.innerWidth;
    canvasHeight = window.innerHeight;

    if (smallScreen) {
        // Reducir resolución física en móvil para mejorar rendimiento
        canvas.width = canvasWidth * 0.6;
        canvas.height = canvasHeight * 0.6;
        canvas.style.width = canvasWidth + 'px';
        canvas.style.height = canvasHeight + 'px';
    } else {
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
    }
}

// Crear estrellas con propiedades aleatorias - con aspecto más realista
function createStars() {
    stars = [];
    const smallScreen = isMobileDevice();

    const starCount = smallScreen
        ? Math.floor(canvasWidth * canvasHeight / 1800 * 0.5)
        : Math.floor(canvasWidth * canvasHeight / 1800 * 2);

    for (let i = 0; i < starCount; i++) {
        const x = Math.random() * canvasWidth;
        const y = Math.random() * canvasHeight;

        let size;
        const sizeRand = Math.random();
        if (sizeRand < 0.7) {
            size = (Math.random() * 1.0 + 0.3) * (smallScreen ? 0.7 : 1);
        } else if (sizeRand < 0.95) {
            size = (Math.random() * 1.5 + 1.0) * (smallScreen ? 0.7 : 1);
        } else {
            size = (Math.random() * 2.0 + 1.5) * (smallScreen ? 0.7 : 1);
        }

        let color;
        const colorRand = Math.random();

        if (colorRand < 0.65) {
            const blue = 220 + Math.floor(Math.random() * 35);
            const green = blue - Math.floor(Math.random() * 20);
            const red = green - Math.floor(Math.random() * 20);
            color = `rgb(${red}, ${green}, ${blue})`;
        } else if (colorRand < 0.85) {
            const red = 220 + Math.floor(Math.random() * 35);
            const green = red - Math.floor(Math.random() * 20);
            const blue = green - Math.floor(Math.random() * 40);
            color = `rgb(${red}, ${green}, ${blue})`;
        } else if (colorRand < 0.95) {
            const red = 220 + Math.floor(Math.random() * 35);
            const green = 130 + Math.floor(Math.random() * 40);
            const blue = 100 + Math.floor(Math.random() * 30);
            color = `rgb(${red}, ${green}, ${blue})`;
        } else {
            color = `rgb(255, 255, 255)`;
        }

        const minOpacity = 0.3 + Math.random() * 0.3;
        const maxOpacity = minOpacity + Math.random() * 0.4;
        const minScale = 0.85 + Math.random() * 0.1;
        const maxScale = minScale + Math.random() * 0.2;
        const twinkleSpeed = Math.random() * 0.02 + 0.005;
        const offset = Math.random() * Math.PI * 2;
        const glow = size * (Math.random() * 2 + 1);

        stars.push({
            x,
            y,
            size,
            color,
            minOpacity,
            maxOpacity,
            minScale,
            maxScale,
            twinkleSpeed,
            offset,
            twinkleValue: offset,
            glow,
            isBright: false
        });
    }

    // Estrellas brillantes reducidas en móvil
    const brightStarsCount = smallScreen ? 4 : 10;
    for (let i = 0; i < brightStarsCount; i++) {
        const x = Math.random() * canvasWidth;
        const y = Math.random() * canvasHeight;
        const size = Math.random() * 2 + 2;

        let colorType = Math.random();
        let color;
        if (colorType < 0.5) {
            color = '#ffffff';
        } else if (colorType < 0.8) {
            color = 'rgb(200, 220, 255)';
        } else {
            color = 'rgb(255, 250, 220)';
        }

        stars.push({
            x,
            y,
            size,
            color,
            minOpacity: 0.7,
            maxOpacity: 1,
            minScale: 0.9,
            maxScale: 1.2,
            twinkleSpeed: Math.random() * 0.01 + 0.003,
            offset: Math.random() * Math.PI * 2,
            twinkleValue: Math.random() * Math.PI * 2,
            glow: Math.random() * 6 + 4,
            isBright: true
        });
    }
}

// Nebulosas reducidas en móvil
function createNebulas() {
    const nebulaContainer = document.getElementById('galaxy');
    if (!nebulaContainer) return;

    while (nebulaContainer.firstChild) {
        nebulaContainer.removeChild(nebulaContainer.firstChild);
    }

    const smallScreen = isMobileDevice();
    const nebulaCount = smallScreen ? 3 : 8;

    for (let i = 0; i < nebulaCount; i++) {
        const nebula = document.createElement('div');
        nebula.className = 'nebula';
        nebula.style.position = 'absolute';

        const width = Math.random() * 400 + 200;
        const height = Math.random() * 300 + 150;
        nebula.style.width = `${width}px`;
        nebula.style.height = `${height}px`;

        nebula.style.top = `${Math.random() * 80}%`;
        nebula.style.left = `${Math.random() * 80}%`;

        let r, g, b, opacity;
        const nebulaType = Math.random();

        if (nebulaType < 0.4) {
            r = Math.floor(Math.random() * 60 + 20);
            g = Math.floor(Math.random() * 80 + 40);
            b = Math.floor(Math.random() * 120 + 100);
            opacity = 0.05;
        } else if (nebulaType < 0.7) {
            r = Math.floor(Math.random() * 100 + 80);
            g = Math.floor(Math.random() * 40 + 20);
            b = Math.floor(Math.random() * 100 + 80);
            opacity = 0.04;
        } else {
            r = Math.floor(Math.random() * 40 + 20);
            g = Math.floor(Math.random() * 100 + 60);
            b = Math.floor(Math.random() * 90 + 70);
            opacity = 0.03;
        }

        nebula.style.background = `radial-gradient(ellipse at center, 
                rgba(${r}, ${g}, ${b}, 0) 0%, 
                rgba(${r}, ${g}, ${b}, ${opacity}) 50%, 
                rgba(${r}, ${g}, ${b}, ${opacity * 0.8}) 70%, 
                rgba(${r}, ${g}, ${b}, 0) 100%)`;

        nebula.style.borderRadius = '50%';
        nebula.style.transform = `rotate(${Math.random() * 360}deg)`;
        nebula.style.opacity = '1';
        nebula.style.filter = 'blur(40px)';
        nebula.style.zIndex = '-1';

        nebulaContainer.appendChild(nebula);
    }
}

function animate() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    stars.forEach(star => {
        star.twinkleValue += star.twinkleSpeed;

        const sinValue = Math.sin(star.twinkleValue + star.offset);
        const normalizedSin = (sinValue + 1) / 2;

        const currentOpacity = star.minOpacity + normalizedSin * (star.maxOpacity - star.minOpacity);
        const currentScale = star.minScale + normalizedSin * (star.maxScale - star.minScale);

        ctx.save();

        ctx.globalAlpha = currentOpacity;

        if (star.size < 1.5) {
            ctx.fillStyle = star.color;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size * currentScale, 0, Math.PI * 2);
            ctx.fill();

            if (Math.random() > 0.8) {
                ctx.globalAlpha = currentOpacity * 0.3;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size * currentScale * 3, 0, Math.PI * 2);
                ctx.fill();
            }
        } else {
            const glow = star.isBright ? star.glow * 0.4 : star.glow;

            const gradient = ctx.createRadialGradient(
                star.x, star.y, 0,
                star.x, star.y, glow * currentScale
            );

            const baseColor = star.color;
            gradient.addColorStop(0, baseColor);
            gradient.addColorStop(0.5, baseColor.replace('rgb', 'rgba').replace(')', ', 0.3)'));
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(star.x, star.y, glow * currentScale, 0, Math.PI * 2);
            ctx.fill();

            if (star.isBright && Math.random() > 0.7) {
                ctx.globalAlpha = currentOpacity * 0.4;
                const numRays = 4;
                const rayLength = star.size * 5 * currentScale;

                ctx.strokeStyle = star.color;
                ctx.lineWidth = 0.5;

                for (let i = 0; i < numRays; i++) {
                    const angle = (i / numRays) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(star.x, star.y);
                    ctx.lineTo(
                        star.x + Math.cos(angle) * rayLength,
                        star.y + Math.sin(angle) * rayLength
                    );
                    ctx.stroke();
                }
            }
        }

        ctx.restore();
    });

    animationFrameId = requestAnimationFrame(animate);
}

function createShootingStar() {
    const shootingStar = document.createElement('div');
    shootingStar.className = 'shooting-star';

    const startX = Math.random() * window.innerWidth;
    const startY = Math.random() * (window.innerHeight / 3);

    shootingStar.style.left = `${startX}px`;
    shootingStar.style.top = `${startY}px`;

    const angle = 30;
    const distance = Math.random() * 300 + 200;
    const endX = startX + distance * Math.sin(angle * Math.PI / 180);
    const endY = startY + distance * Math.cos(angle * Math.PI / 180);

    shootingStar.style.width = '2px';
    shootingStar.style.height = '2px';
    shootingStar.style.backgroundColor = 'white';
    shootingStar.style.borderRadius = '50%';
    shootingStar.style.boxShadow = '0 0 20px 1px white';
    shootingStar.style.opacity = '0';
    shootingStar.style.zIndex = '1';
    shootingStar.style.position = 'absolute';

    document.body.appendChild(shootingStar);

    const keyframes = [
        { left: `${startX}px`, top: `${startY}px`, opacity: 0, boxShadow: '0 0 1px 1px white', offset: 0 },
        { opacity: 1, boxShadow: '0 0 2px 1px white, 0 0 40px 7px rgba(255, 255, 255, 0.7)', offset: 0.1 },
        { left: `${endX}px`, top: `${endY}px`, opacity: 0, boxShadow: '0 0 1px 1px white', offset: 1 }
    ];

    const timing = {
        duration: Math.random() * 1000 + 1000,
        iterations: 1,
        easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)'
    };

    shootingStar.animate(keyframes, timing);

    setTimeout(() => {
        if (document.body.contains(shootingStar)) {
            document.body.removeChild(shootingStar);
        }
    }, timing.duration);
}

function startShootingStars() {
    const intervalTime = isMobileDevice() ? 700 : 200;
    setInterval(() => {
        if (Math.random() > 0.7) {
            createShootingStar();
        }
    }, intervalTime);
}

// Silueta Simpsons
function setupSimpsonSilhouette() {
    const silhouette = document.querySelector('.simpson-silhouette');
    if (silhouette) {
        silhouette.style.backgroundSize = "contain";
        silhouette.style.backgroundPosition = "center bottom";
        silhouette.style.backgroundRepeat = "no-repeat";
        silhouette.style.backgroundImage = "url(part.png)";
    }
}

// --- Reproductor de audio y visualizador --- 
// (Aquí mantengo tu código sin cambios relevantes para rendimiento, solo omití por brevedad)
// Puedes agregarlo nuevamente igual a tu original.

let audioPlayer, audioContext, analyser, dataArray;
let audioSource, canvasContext, visualizerCanvas;
let isPlaying = false;
let visualizerAnimationId;

function setupPlayer() {
    audioPlayer = new Audio('close_to_you.mp3');

    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 256;
    const bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);

    createVisualizer();

    const playBtn = document.querySelector('.play-btn');
    if (playBtn) {
        playBtn.addEventListener('click', togglePlay);
    }

    const progressContainer = document.querySelector('.progress-container');
    if (progressContainer) {
        progressContainer.addEventListener('click', setProgress);
    }

    audioPlayer.addEventListener('loadedmetadata', () => {
        document.querySelector('.time-info').lastElementChild.textContent = formatTime(audioPlayer.duration);
        updateProgress();
    });

    audioPlayer.addEventListener('timeupdate', updateProgress);

    audioPlayer.addEventListener('ended', () => {
        isPlaying = false;
        playBtn.textContent = '▶';
        cancelAnimationFrame(animationFrameId);
        resetVisualizer();
    });

    const prevBtn = document.querySelector('.controls').firstElementChild;
    const nextBtn = document.querySelector('.controls').lastElementChild;
    if (prevBtn) prevBtn.addEventListener('click', () => alert('Función no implementada: Canción anterior'));
    if (nextBtn) nextBtn.addEventListener('click', () => alert('Función no implementada: Siguiente canción'));
}

function createVisualizer() {
    visualizerCanvas = document.createElement('canvas');
    visualizerCanvas.className = 'audio-visualizer';

    const albumArt = document.querySelector('.album-art');

    visualizerCanvas.width = albumArt ? albumArt.offsetWidth * 0.8 : 200;
    visualizerCanvas.height = albumArt ? albumArt.offsetHeight * 0.3 : 60;

    visualizerCanvas.style.position = 'absolute';
    visualizerCanvas.style.bottom = '20px';
    visualizerCanvas.style.left = '50%';
    visualizerCanvas.style.transform = 'translateX(-50%)';
    visualizerCanvas.style.borderRadius = '3px';
    visualizerCanvas.style.opacity = '1';
    visualizerCanvas.style.zIndex = '10';

    if (albumArt) {
        albumArt.appendChild(visualizerCanvas);
    } else {
        const playerContainer = document.querySelector('.player-container');
        if (playerContainer) {
            playerContainer.appendChild(visualizerCanvas);
        }
    }

    canvasContext = visualizerCanvas.getContext('2d');
}

function resetVisualizer() {
    if (canvasContext && visualizerCanvas) {
        canvasContext.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
    }
}

function togglePlay() {
    const playBtn = document.querySelector('.play-btn');
    if (!audioContext || audioContext.state === 'suspended') {
        audioContext.resume();
    }
    if (isPlaying) {
        audioPlayer.pause();
        playBtn.textContent = '▶';
        isPlaying = false;
        cancelAnimationFrame(visualizerAnimationId);
    } else {
        audioPlayer.play().then(() => {
            playBtn.textContent = '⏸';
            isPlaying = true;
            if (!audioSource) {
                audioSource = audioContext.createMediaElementSource(audioPlayer);
                audioSource.connect(analyser);
                analyser.connect(audioContext.destination);
            }
            visualize();
        }).catch(error => {
            console.error('Error al reproducir el audio:', error);
        });
    }
}

function formatTime(time) {
    const minutes = Math.floor(time / 60);
    let seconds = Math.floor(time % 60);
    seconds = seconds < 10 ? `0${seconds}` : seconds;
    return `${minutes}:${seconds}`;
}

function updateProgress() {
    const progressBar = document.querySelector('.progress-bar');
    const currentTimeElement = document.querySelector('.time-info').firstElementChild;

    if (progressBar && currentTimeElement && audioPlayer) {
        const currentTime = audioPlayer.currentTime;
        const duration = audioPlayer.duration || 1;

        const progressPercent = (currentTime / duration) * 100;
        progressBar.style.width = `${progressPercent}%`;

        currentTimeElement.textContent = formatTime(currentTime);
    }
}

function setProgress(e) {
    const progressContainer = document.querySelector('.progress-container');
    const width = progressContainer.clientWidth;
    const clickX = e.offsetX;

    if (audioPlayer && audioPlayer.duration) {
        const duration = audioPlayer.duration;
        audioPlayer.currentTime = (clickX / width) * duration;
    }
}

function visualize() {
    analyser.getByteFrequencyData(dataArray);

    canvasContext.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

    const barCount = 16;
    const barWidth = visualizerCanvas.width / barCount - 1;
    const barSpacing = 1;
    const barHeightFactor = visualizerCanvas.height / 255;

    for (let i = 0; i < barCount; i++) {
        const frequencyRange = dataArray.length * 0.6;
        const startOffset = dataArray.length * 0.1;

        const index = Math.floor(startOffset + (i / barCount) * frequencyRange);

        let value = dataArray[index];

        if (i > barCount / 2) {
            value = Math.min(255, value * 1.4);
        }

        const barHeight = Math.max(4, value * barHeightFactor);

        canvasContext.fillStyle = '#FFFFFF';

        const x = i * (barWidth + barSpacing);

        canvasContext.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);
    }

    if (isPlaying) {
        visualizerAnimationId = requestAnimationFrame(visualize);
    }
}

window.addEventListener('beforeunload', function () {
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }
});
